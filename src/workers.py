import asyncio
from datetime import datetime, timezone

from src import globals
from src.db import register_payment_db
from src.encoders import health_check_decoder, encoder
from src.models import Payment


async def payment_processor_health_checker():
    while True:
        last_health_check = await globals.redis_client.get("payment_processor_health")
        if not last_health_check:
            last_health_check = {
                "default": None,
                "fallback": None,
            }
        else:
            last_health_check = health_check_decoder.decode(last_health_check)
        try:
            default_health = await make_health_check_request("default")
            if default_health:
                last_health_check["default"] = default_health
            fallback_health = await make_health_check_request("fallback")
            if fallback_health:
                last_health_check["fallback"] = fallback_health
        except Exception as e:
            globals.logger.error(f"Health check failed: {e}")
            continue
        await globals.redis_client.set(
            "payment_processor_health", encoder.encode(last_health_check)
        )
        globals.cached_health_check = last_health_check
        globals.logger.info(f"Health check updated: {last_health_check}")
        await asyncio.sleep(5)


async def make_health_check_request(payment_processor="default"):
    health_check_urls = {
        "default": globals.payment_processor_url + "/payments/service-health",
        "fallback": globals.fallback_payment_processor_url + "/payments/service-health",
    }
    async with globals.session.get(health_check_urls[payment_processor]) as response:
        if response.status == 200:
            health_check_value = await response.json()
            health_check_value["timestamp"] = datetime.now(timezone.utc).isoformat()
            return health_check_value
        else:
            return None


async def set_best_payment_processor():
    health_check = globals.cached_health_check
    if not health_check:
        raw_health_check = await globals.redis_client.get("payment_processor_health")
        if not raw_health_check:
            return "default"
        health_check = health_check_decoder.decode(raw_health_check)

    globals.logger.info(f"Current health check: {health_check}")
    default = health_check.get("default")
    fallback = health_check.get("fallback")

    if not (default and fallback):
        return "default"

    if default["failing"] and not fallback["failing"]:
        return "fallback"
    elif fallback["failing"] and not default["failing"]:
        return "default"
    elif not default["failing"] and not fallback["failing"]:
        if default["minResponseTime"] <= fallback["minResponseTime"]:
            return "default"

        if default["minResponseTime"] > fallback["minResponseTime"]:
            return "fallback"

        return "fallback"

    return "default"


async def make_payment_request(payment_payload, processor, max_attempts=3) -> str:
    urls = {
        "default": globals.payment_processor_url + "/payments",
        "fallback": globals.fallback_payment_processor_url + "/payments",
    }
    attempt = 0
    while attempt < max_attempts:
        globals.logger.info(
            f"Attempt {attempt + 1}: Sending payment request to {processor}"
        )
        async with globals.session.post(
            urls[processor], json=payment_payload
        ) as response:
            if response.status == 200:
                return processor
            globals.logger.error(
                f"Payment request failed for {processor}: {response.status} {await response.text()}"
            )
            attempt += 1
    if processor == "default":
        return await make_payment_request(payment_payload, "fallback", max_attempts)
    raise Exception("Both payment processors failed after multiple attempts.")


async def payment_worker():
    while True:
        payment_request = await globals.payment_queue.get()
        if payment_request is None:
            break
        await process_payment(payment_request)
        globals.payment_queue.task_done()


async def process_payment(payment_request):
    requested_at = datetime.now(timezone.utc)
    try:
        processors = await set_best_payment_processor()
        payment_request["requestedAt"] = requested_at.isoformat()
        start_time = datetime.now(timezone.utc)
        payment_processor = await make_payment_request(
            payment_request, processor=processors
        )
        end_time = datetime.now(timezone.utc)
        execution_time = (end_time - start_time).total_seconds() * 1000  # Convert to milliseconds
        globals.logger.info(
            f"Payment request for {payment_request['correlationId']} executed in {execution_time} milliseconds using {payment_processor}"
        )
        payment = Payment(
            id=None,  # ID will be auto-generated by the database
            correlation_id=payment_request["correlationId"],
            amount=payment_request["amount"],
            requested_at=requested_at.isoformat(),
            payment_processor=payment_processor,
        )
        start_time = datetime.now(timezone.utc)
        await register_payment_db(payment)
        end_time = datetime.now(timezone.utc)
        db_execution_time = (end_time - start_time).total_seconds() * 1000 # Convert to milliseconds
        globals.logger.info(
            f"Payment for {payment_request['correlationId']} registered in the database in {db_execution_time} milliseconds"
        )
    except Exception:
        globals.logger.error(
            f"Payment processing failed for {payment_request['correlationId']}: {payment_request}"
        )
        await globals.payment_queue.put(payment_request)
